"""
Interface de busca avan√ßada para documentos OCR
Integra com SearchManager para busca inteligente
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import asyncio
import threading
from typing import List, Dict, Any
import os
from datetime import datetime
import webbrowser
import subprocess
import platform

class SearchInterface:
    """Interface gr√°fica para busca avan√ßada de documentos"""
    
    def __init__(self, parent, search_manager=None):
        self.parent = parent
        self.search_manager = search_manager
        self.search_results = []
        self.current_page = 0
        self.results_per_page = 10
        
        # Vari√°veis de controle
        self.search_var = tk.StringVar()
        self.search_type_var = tk.StringVar(value="mixed")
        self.max_results_var = tk.IntVar(value=20)
        
        self.create_search_interface()
        self.load_search_statistics()
    
    def create_search_interface(self):
        """Cria interface de busca"""
        # Frame principal
        self.main_frame = ttk.Frame(self.parent, padding="10")
        self.main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configurar redimensionamento
        self.parent.columnconfigure(0, weight=1)
        self.parent.rowconfigure(0, weight=1)
        self.main_frame.columnconfigure(1, weight=1)
        
        # === SE√á√ÉO DE BUSCA ===
        search_frame = ttk.LabelFrame(self.main_frame, text="üîç Busca Inteligente", padding="10")
        search_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        search_frame.columnconfigure(1, weight=1)
        
        # Campo de busca
        ttk.Label(search_frame, text="Buscar:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))\n        \n        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var, font=("Arial", 12))\n        self.search_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 5))\n        self.search_entry.bind('<Return>', lambda e: self.perform_search())\n        \n        # Bot√£o de busca\n        self.search_button = ttk.Button(search_frame, text="Buscar", command=self.perform_search)\n        self.search_button.grid(row=0, column=2, padx=(5, 0))\n        \n        # Op√ß√µes de busca\n        options_frame = ttk.Frame(search_frame)\n        options_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(10, 0))\n        \n        # Tipo de busca\n        ttk.Label(options_frame, text="Tipo:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))\n        \n        search_type_combo = ttk.Combobox(options_frame, textvariable=self.search_type_var, \n                                        values=["mixed", "exact", "fuzzy", "semantic"], \n                                        state="readonly", width=10)\n        search_type_combo.grid(row=0, column=1, sticky=tk.W, padx=(0, 20))\n        \n        # N√∫mero m√°ximo de resultados\n        ttk.Label(options_frame, text="M√°x. resultados:").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))\n        \n        max_results_spin = ttk.Spinbox(options_frame, from_=5, to=100, textvariable=self.max_results_var, \n                                      width=8, state="readonly")\n        max_results_spin.grid(row=0, column=3, sticky=tk.W, padx=(0, 20))\n        \n        # Bot√£o de configura√ß√£o\n        self.config_button = ttk.Button(options_frame, text="Configurar Busca", \n                                       command=self.open_search_config)\n        self.config_button.grid(row=0, column=4, padx=(20, 0))\n        \n        # === SE√á√ÉO DE RESULTADOS ===\n        results_frame = ttk.LabelFrame(self.main_frame, text="üìã Resultados", padding="10")\n        results_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))\n        results_frame.columnconfigure(0, weight=1)\n        results_frame.rowconfigure(1, weight=1)\n        \n        # Informa√ß√µes dos resultados\n        self.results_info_label = ttk.Label(results_frame, text="Digite uma consulta para buscar documentos")\n        self.results_info_label.grid(row=0, column=0, sticky=tk.W, pady=(0, 10))\n        \n        # Lista de resultados\n        self.create_results_tree(results_frame)\n        \n        # Navega√ß√£o de p√°ginas\n        self.create_pagination_controls(results_frame)\n        \n        # === SE√á√ÉO DE ESTAT√çSTICAS ===\n        stats_frame = ttk.LabelFrame(self.main_frame, text="üìä Estat√≠sticas", padding="10")\n        stats_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\n        \n        self.create_statistics_section(stats_frame)\n        \n        # === SE√á√ÉO DE A√á√ïES ===\n        actions_frame = ttk.LabelFrame(self.main_frame, text="‚öôÔ∏è A√ß√µes", padding="10")\n        actions_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E))\n        \n        self.create_actions_section(actions_frame)\n    \n    def create_results_tree(self, parent):\n        """Cria √°rvore de resultados"""\n        # Frame para treeview com scrollbar\n        tree_frame = ttk.Frame(parent)\n        tree_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        tree_frame.columnconfigure(0, weight=1)\n        tree_frame.rowconfigure(0, weight=1)\n        \n        # Treeview\n        columns = ('Documento', 'P√°gina', 'Tipo', 'Score', 'Confian√ßa')\n        self.results_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=12)\n        \n        # Configurar colunas\n        self.results_tree.heading('Documento', text='Documento')\n        self.results_tree.heading('P√°gina', text='P√°gina')\n        self.results_tree.heading('Tipo', text='Tipo')\n        self.results_tree.heading('Score', text='Score')\n        self.results_tree.heading('Confian√ßa', text='Confian√ßa')\n        \n        self.results_tree.column('Documento', width=300)\n        self.results_tree.column('P√°gina', width=80, anchor='center')\n        self.results_tree.column('Tipo', width=100, anchor='center')\n        self.results_tree.column('Score', width=80, anchor='center')\n        self.results_tree.column('Confian√ßa', width=100, anchor='center')\n        \n        self.results_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n        \n        # Scrollbar\n        scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.results_tree.yview)\n        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))\n        self.results_tree.configure(yscrollcommand=scrollbar.set)\n        \n        # Bind duplo clique\n        self.results_tree.bind('<Double-1>', self.on_result_double_click)\n        \n        # Menu de contexto\n        self.create_context_menu()\n    \n    def create_context_menu(self):\n        """Cria menu de contexto para resultados"""\n        self.context_menu = tk.Menu(self.results_tree, tearoff=0)\n        self.context_menu.add_command(label="Abrir Documento", command=self.open_selected_document)\n        self.context_menu.add_command(label="Mostrar Excerto", command=self.show_excerpt)\n        self.context_menu.add_separator()\n        self.context_menu.add_command(label="Copiar Caminho", command=self.copy_file_path)\n        self.context_menu.add_command(label="Abrir Pasta", command=self.open_file_folder)\n        \n        # Bind menu de contexto\n        self.results_tree.bind('<Button-3>', self.show_context_menu)\n    \n    def create_pagination_controls(self, parent):\n        """Cria controles de pagina√ß√£o"""\n        pagination_frame = ttk.Frame(parent)\n        pagination_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=(10, 0))\n        \n        # Bot√µes de navega√ß√£o\n        self.prev_button = ttk.Button(pagination_frame, text=\"‚óÄ Anterior\", \n                                     command=self.previous_page, state='disabled')\n        self.prev_button.grid(row=0, column=0, padx=(0, 5))\n        \n        self.page_label = ttk.Label(pagination_frame, text=\"P√°gina 0 de 0\")\n        self.page_label.grid(row=0, column=1, padx=(5, 5))\n        \n        self.next_button = ttk.Button(pagination_frame, text=\"Pr√≥ximo ‚ñ∂\", \n                                     command=self.next_page, state='disabled')\n        self.next_button.grid(row=0, column=2, padx=(5, 0))\n        \n        # Spacer\n        pagination_frame.columnconfigure(3, weight=1)\n        \n        # Informa√ß√µes da p√°gina\n        self.page_info_label = ttk.Label(pagination_frame, text=\"\")\n        self.page_info_label.grid(row=0, column=4, sticky=tk.E)\n    \n    def create_statistics_section(self, parent):\n        """Cria se√ß√£o de estat√≠sticas"""\n        # Frame para estat√≠sticas em duas colunas\n        stats_left = ttk.Frame(parent)\n        stats_left.grid(row=0, column=0, sticky=(tk.W, tk.N), padx=(0, 20))\n        \n        stats_right = ttk.Frame(parent)\n        stats_right.grid(row=0, column=1, sticky=(tk.W, tk.N))\n        \n        # Estat√≠sticas da esquerda\n        self.total_docs_label = ttk.Label(stats_left, text=\"Total de documentos: 0\")\n        self.total_docs_label.grid(row=0, column=0, sticky=tk.W, pady=2)\n        \n        self.total_pages_label = ttk.Label(stats_left, text=\"Total de p√°ginas: 0\")\n        self.total_pages_label.grid(row=1, column=0, sticky=tk.W, pady=2)\n        \n        self.elasticsearch_label = ttk.Label(stats_left, text=\"Elasticsearch: Desabilitado\")\n        self.elasticsearch_label.grid(row=2, column=0, sticky=tk.W, pady=2)\n        \n        # Estat√≠sticas da direita\n        self.semantic_label = ttk.Label(stats_right, text=\"Busca sem√¢ntica: Desabilitada\")\n        self.semantic_label.grid(row=0, column=0, sticky=tk.W, pady=2)\n        \n        self.embeddings_label = ttk.Label(stats_right, text=\"Embeddings: 0\")\n        self.embeddings_label.grid(row=1, column=0, sticky=tk.W, pady=2)\n        \n        self.last_search_label = ttk.Label(stats_right, text=\"√öltima busca: Nunca\")\n        self.last_search_label.grid(row=2, column=0, sticky=tk.W, pady=2)\n    \n    def create_actions_section(self, parent):\n        """Cria se√ß√£o de a√ß√µes"""\n        # Bot√µes de a√ß√£o\n        self.rebuild_index_button = ttk.Button(parent, text=\"Reconstruir √çndice\", \n                                              command=self.rebuild_search_index)\n        self.rebuild_index_button.grid(row=0, column=0, padx=(0, 10))\n        \n        self.clear_index_button = ttk.Button(parent, text=\"Limpar √çndice\", \n                                            command=self.clear_search_index)\n        self.clear_index_button.grid(row=0, column=1, padx=(0, 10))\n        \n        self.export_results_button = ttk.Button(parent, text=\"Exportar Resultados\", \n                                               command=self.export_search_results)\n        self.export_results_button.grid(row=0, column=2, padx=(0, 10))\n        \n        # Spacer\n        parent.columnconfigure(3, weight=1)\n        \n        # Bot√£o de atualiza√ß√£o\n        self.refresh_button = ttk.Button(parent, text=\"üîÑ Atualizar\", \n                                        command=self.refresh_statistics)\n        self.refresh_button.grid(row=0, column=4)\n    \n    def perform_search(self):\n        """Executa busca de documentos"""\n        query = self.search_var.get().strip()\n        if not query:\n            messagebox.showwarning(\"Aviso\", \"Digite uma consulta para buscar\")\n            return\n        \n        if not self.search_manager:\n            messagebox.showerror(\"Erro\", \"Sistema de busca n√£o est√° dispon√≠vel\")\n            return\n        \n        # Executar busca em thread separada\n        self.search_button.config(state='disabled', text=\"Buscando...\")\n        self.results_info_label.config(text=\"Buscando documentos...\")\n        \n        thread = threading.Thread(target=self._search_thread, args=(query,))\n        thread.daemon = True\n        thread.start()\n    \n    def _search_thread(self, query):\n        """Executa busca em thread separada"""\n        try:\n            # Criar loop de eventos para async\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            # Executar busca\n            search_type = self.search_type_var.get()\n            max_results = self.max_results_var.get()\n            \n            results = loop.run_until_complete(\n                self.search_manager.search_documents(query, max_results, search_type)\n            )\n            \n            # Atualizar interface no thread principal\n            self.parent.after(0, self._update_search_results, results, query)\n            \n        except Exception as e:\n            self.parent.after(0, self._search_error, str(e))\n        finally:\n            loop.close()\n    \n    def _update_search_results(self, results, query):\n        """Atualiza resultados na interface"""\n        self.search_results = results\n        self.current_page = 0\n        \n        # Atualizar informa√ß√µes\n        self.results_info_label.config(text=f\"Encontrados {len(results)} resultados para '{query}'\")\n        self.last_search_label.config(text=f\"√öltima busca: {datetime.now().strftime('%H:%M:%S')}\")\n        \n        # Mostrar resultados\n        self.update_results_display()\n        \n        # Reabilitar bot√£o\n        self.search_button.config(state='normal', text=\"Buscar\")\n    \n    def _search_error(self, error_msg):\n        """Trata erro de busca"""\n        self.results_info_label.config(text=f\"Erro na busca: {error_msg}\")\n        self.search_button.config(state='normal', text=\"Buscar\")\n        messagebox.showerror(\"Erro de Busca\", f\"Erro ao buscar documentos:\\n{error_msg}\")\n    \n    def update_results_display(self):\n        \"\"\"Atualiza exibi√ß√£o dos resultados\"\"\"\n        # Limpar √°rvore\n        for item in self.results_tree.get_children():\n            self.results_tree.delete(item)\n        \n        if not self.search_results:\n            self.update_pagination_controls()\n            return\n        \n        # Calcular p√°ginas\n        total_pages = (len(self.search_results) - 1) // self.results_per_page + 1\n        start_idx = self.current_page * self.results_per_page\n        end_idx = start_idx + self.results_per_page\n        \n        # Mostrar resultados da p√°gina atual\n        for result in self.search_results[start_idx:end_idx]:\n            # Formatar valores\n            doc_name = os.path.basename(result.title)\n            page_num = result.page_number\n            match_type = result.match_type.title()\n            score = f\"{result.score:.2f}\"\n            confidence = f\"{result.confidence:.2%}\"\n            \n            # Inserir na √°rvore\n            item = self.results_tree.insert('', 'end', values=(\n                doc_name, page_num, match_type, score, confidence\n            ))\n            \n            # Armazenar refer√™ncia ao resultado\n            self.results_tree.set(item, 'result_data', result)\n        \n        # Atualizar controles de pagina√ß√£o\n        self.update_pagination_controls()\n    \n    def update_pagination_controls(self):\n        \"\"\"Atualiza controles de pagina√ß√£o\"\"\"\n        if not self.search_results:\n            self.page_label.config(text=\"P√°gina 0 de 0\")\n            self.page_info_label.config(text=\"\")\n            self.prev_button.config(state='disabled')\n            self.next_button.config(state='disabled')\n            return\n        \n        total_pages = (len(self.search_results) - 1) // self.results_per_page + 1\n        current_page_display = self.current_page + 1\n        \n        # Atualizar labels\n        self.page_label.config(text=f\"P√°gina {current_page_display} de {total_pages}\")\n        \n        start_idx = self.current_page * self.results_per_page + 1\n        end_idx = min((self.current_page + 1) * self.results_per_page, len(self.search_results))\n        self.page_info_label.config(text=f\"Mostrando {start_idx}-{end_idx} de {len(self.search_results)}\")\n        \n        # Atualizar bot√µes\n        self.prev_button.config(state='normal' if self.current_page > 0 else 'disabled')\n        self.next_button.config(state='normal' if self.current_page < total_pages - 1 else 'disabled')\n    \n    def previous_page(self):\n        \"\"\"Vai para p√°gina anterior\"\"\"\n        if self.current_page > 0:\n            self.current_page -= 1\n            self.update_results_display()\n    \n    def next_page(self):\n        \"\"\"Vai para pr√≥xima p√°gina\"\"\"\n        total_pages = (len(self.search_results) - 1) // self.results_per_page + 1\n        if self.current_page < total_pages - 1:\n            self.current_page += 1\n            self.update_results_display()\n    \n    def load_search_statistics(self):\n        \"\"\"Carrega estat√≠sticas do sistema de busca\"\"\"\n        if not self.search_manager:\n            return\n        \n        # Executar em thread separada\n        thread = threading.Thread(target=self._load_statistics_thread)\n        thread.daemon = True\n        thread.start()\n    \n    def _load_statistics_thread(self):\n        \"\"\"Carrega estat√≠sticas em thread separada\"\"\"\n        try:\n            # Criar loop de eventos para async\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            # Obter estat√≠sticas\n            stats = loop.run_until_complete(self.search_manager.get_document_statistics())\n            \n            # Atualizar interface no thread principal\n            self.parent.after(0, self._update_statistics, stats)\n            \n        except Exception as e:\n            print(f\"Erro ao carregar estat√≠sticas: {e}\")\n        finally:\n            loop.close()\n    \n    def _update_statistics(self, stats):\n        \"\"\"Atualiza estat√≠sticas na interface\"\"\"\n        # Atualizar labels\n        self.total_docs_label.config(text=f\"Total de documentos: {stats.get('total_documents', 0)}\")\n        self.total_pages_label.config(text=f\"Total de p√°ginas: {stats.get('total_pages', 0)}\")\n        \n        es_status = \"Habilitado\" if stats.get('elasticsearch_enabled', False) else \"Desabilitado\"\n        self.elasticsearch_label.config(text=f\"Elasticsearch: {es_status}\")\n        \n        semantic_status = \"Habilitada\" if stats.get('semantic_search_enabled', False) else \"Desabilitada\"\n        self.semantic_label.config(text=f\"Busca sem√¢ntica: {semantic_status}\")\n        \n        self.embeddings_label.config(text=f\"Embeddings: {stats.get('total_embeddings', 0)}\")\n    \n    def refresh_statistics(self):\n        \"\"\"Atualiza estat√≠sticas\"\"\"\n        self.load_search_statistics()\n    \n    def on_result_double_click(self, event):\n        \"\"\"Trata duplo clique em resultado\"\"\"\n        self.open_selected_document()\n    \n    def show_context_menu(self, event):\n        \"\"\"Mostra menu de contexto\"\"\"\n        # Selecionar item clicado\n        item = self.results_tree.identify_row(event.y)\n        if item:\n            self.results_tree.selection_set(item)\n            self.context_menu.post(event.x_root, event.y_root)\n    \n    def open_selected_document(self):\n        \"\"\"Abre documento selecionado\"\"\"\n        selection = self.results_tree.selection()\n        if not selection:\n            return\n        \n        # Obter resultado selecionado\n        result = self.get_selected_result()\n        if result:\n            self.open_document(result.file_path)\n    \n    def get_selected_result(self):\n        \"\"\"Obt√©m resultado selecionado\"\"\"\n        selection = self.results_tree.selection()\n        if not selection:\n            return None\n        \n        item = selection[0]\n        values = self.results_tree.item(item, 'values')\n        \n        # Encontrar resultado correspondente\n        doc_name = values[0]\n        page_num = int(values[1])\n        \n        for result in self.search_results:\n            if (os.path.basename(result.title) == doc_name and \n                result.page_number == page_num):\n                return result\n        \n        return None\n    \n    def open_document(self, file_path):\n        \"\"\"Abre documento no visualizador padr√£o\"\"\"\n        try:\n            if os.path.exists(file_path):\n                if platform.system() == \"Windows\":\n                    os.startfile(file_path)\n                elif platform.system() == \"Darwin\":  # macOS\n                    subprocess.run([\"open\", file_path])\n                else:  # Linux\n                    subprocess.run([\"xdg-open\", file_path])\n            else:\n                messagebox.showerror(\"Erro\", f\"Arquivo n√£o encontrado:\\n{file_path}\")\n        except Exception as e:\n            messagebox.showerror(\"Erro\", f\"Erro ao abrir documento:\\n{str(e)}\")\n    \n    def show_excerpt(self):\n        \"\"\"Mostra excerto do resultado selecionado\"\"\"\n        result = self.get_selected_result()\n        if not result:\n            return\n        \n        # Criar janela de excerto\n        excerpt_window = tk.Toplevel(self.parent)\n        excerpt_window.title(f\"Excerto - {os.path.basename(result.title)}\")\n        excerpt_window.geometry(\"600x400\")\n        \n        # Texto do excerto\n        text_widget = tk.Text(excerpt_window, wrap=tk.WORD, padx=10, pady=10)\n        text_widget.pack(fill=tk.BOTH, expand=True)\n        \n        # Inserir excerto\n        text_widget.insert(tk.END, result.content_excerpt)\n        text_widget.config(state=tk.DISABLED)\n        \n        # Scrollbar\n        scrollbar = ttk.Scrollbar(excerpt_window, orient=tk.VERTICAL, command=text_widget.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        text_widget.config(yscrollcommand=scrollbar.set)\n    \n    def copy_file_path(self):\n        \"\"\"Copia caminho do arquivo para clipboard\"\"\"\n        result = self.get_selected_result()\n        if result:\n            self.parent.clipboard_clear()\n            self.parent.clipboard_append(result.file_path)\n            messagebox.showinfo(\"Sucesso\", \"Caminho copiado para clipboard\")\n    \n    def open_file_folder(self):\n        \"\"\"Abre pasta do arquivo\"\"\"\n        result = self.get_selected_result()\n        if result:\n            folder_path = os.path.dirname(result.file_path)\n            if os.path.exists(folder_path):\n                if platform.system() == \"Windows\":\n                    os.startfile(folder_path)\n                elif platform.system() == \"Darwin\":  # macOS\n                    subprocess.run([\"open\", folder_path])\n                else:  # Linux\n                    subprocess.run([\"xdg-open\", folder_path])\n            else:\n                messagebox.showerror(\"Erro\", f\"Pasta n√£o encontrada:\\n{folder_path}\")\n    \n    def open_search_config(self):\n        \"\"\"Abre configura√ß√µes de busca\"\"\"\n        if not self.search_manager:\n            messagebox.showerror(\"Erro\", \"Sistema de busca n√£o est√° dispon√≠vel\")\n            return\n        \n        # Criar janela de configura√ß√£o\n        config_window = tk.Toplevel(self.parent)\n        config_window.title(\"Configura√ß√µes de Busca\")\n        config_window.geometry(\"500x400\")\n        \n        # Notebook para abas\n        notebook = ttk.Notebook(config_window)\n        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Aba Elasticsearch\n        es_frame = ttk.Frame(notebook, padding=\"10\")\n        notebook.add(es_frame, text=\"Elasticsearch\")\n        \n        # Aba Busca Sem√¢ntica\n        semantic_frame = ttk.Frame(notebook, padding=\"10\")\n        notebook.add(semantic_frame, text=\"Busca Sem√¢ntica\")\n        \n        # Aba Geral\n        general_frame = ttk.Frame(notebook, padding=\"10\")\n        notebook.add(general_frame, text=\"Geral\")\n        \n        # Implementar configura√ß√µes espec√≠ficas\n        self.create_elasticsearch_config(es_frame)\n        self.create_semantic_config(semantic_frame)\n        self.create_general_config(general_frame)\n    \n    def create_elasticsearch_config(self, parent):\n        \"\"\"Cria configura√ß√£o do Elasticsearch\"\"\"\n        ttk.Label(parent, text=\"Configura√ß√µes do Elasticsearch\").pack(anchor=tk.W, pady=(0, 10))\n        \n        # Checkbox para habilitar\n        self.es_enabled_var = tk.BooleanVar()\n        ttk.Checkbutton(parent, text=\"Habilitar Elasticsearch\", \n                       variable=self.es_enabled_var).pack(anchor=tk.W, pady=5)\n        \n        # Configura√ß√µes de conex√£o\n        ttk.Label(parent, text=\"Host:\").pack(anchor=tk.W, pady=(10, 0))\n        self.es_host_var = tk.StringVar(value=\"localhost\")\n        ttk.Entry(parent, textvariable=self.es_host_var, width=30).pack(anchor=tk.W, pady=2)\n        \n        ttk.Label(parent, text=\"Porta:\").pack(anchor=tk.W, pady=(10, 0))\n        self.es_port_var = tk.StringVar(value=\"9200\")\n        ttk.Entry(parent, textvariable=self.es_port_var, width=30).pack(anchor=tk.W, pady=2)\n    \n    def create_semantic_config(self, parent):\n        \"\"\"Cria configura√ß√£o da busca sem√¢ntica\"\"\"\n        ttk.Label(parent, text=\"Configura√ß√µes da Busca Sem√¢ntica\").pack(anchor=tk.W, pady=(0, 10))\n        \n        # Checkbox para habilitar\n        self.semantic_enabled_var = tk.BooleanVar()\n        ttk.Checkbutton(parent, text=\"Habilitar Busca Sem√¢ntica\", \n                       variable=self.semantic_enabled_var).pack(anchor=tk.W, pady=5)\n        \n        # Modelo de embedding\n        ttk.Label(parent, text=\"Modelo de Embedding:\").pack(anchor=tk.W, pady=(10, 0))\n        self.embedding_model_var = tk.StringVar(value=\"sentence-transformers/all-MiniLM-L6-v2\")\n        ttk.Entry(parent, textvariable=self.embedding_model_var, width=50).pack(anchor=tk.W, pady=2)\n    \n    def create_general_config(self, parent):\n        \"\"\"Cria configura√ß√£o geral\"\"\"\n        ttk.Label(parent, text=\"Configura√ß√µes Gerais\").pack(anchor=tk.W, pady=(0, 10))\n        \n        # Bot√µes de a√ß√£o\n        ttk.Button(parent, text=\"Salvar Configura√ß√µes\", \n                  command=self.save_search_config).pack(anchor=tk.W, pady=5)\n        \n        ttk.Button(parent, text=\"Restaurar Padr√µes\", \n                  command=self.restore_default_config).pack(anchor=tk.W, pady=5)\n    \n    def save_search_config(self):\n        \"\"\"Salva configura√ß√µes de busca\"\"\"\n        # Implementar salvamento\n        messagebox.showinfo(\"Sucesso\", \"Configura√ß√µes salvas com sucesso!\")\n    \n    def restore_default_config(self):\n        \"\"\"Restaura configura√ß√µes padr√£o\"\"\"\n        # Implementar restaura√ß√£o\n        messagebox.showinfo(\"Sucesso\", \"Configura√ß√µes restauradas para padr√£o!\")\n    \n    def rebuild_search_index(self):\n        \"\"\"Reconstr√≥i √≠ndice de busca\"\"\"\n        if messagebox.askyesno(\"Confirmar\", \"Deseja reconstruir o √≠ndice de busca?\\n\\nIsso pode demorar alguns minutos.\"):\n            messagebox.showinfo(\"Info\", \"Funcionalidade de reconstru√ß√£o ser√° implementada\")\n    \n    def clear_search_index(self):\n        \"\"\"Limpa √≠ndice de busca\"\"\"\n        if messagebox.askyesno(\"Confirmar\", \"Deseja limpar completamente o √≠ndice de busca?\\n\\nEsta a√ß√£o n√£o pode ser desfeita.\"):\n            if self.search_manager:\n                # Executar limpeza em thread separada\n                thread = threading.Thread(target=self._clear_index_thread)\n                thread.daemon = True\n                thread.start()\n    \n    def _clear_index_thread(self):\n        \"\"\"Limpa √≠ndice em thread separada\"\"\"\n        try:\n            # Criar loop de eventos para async\n            loop = asyncio.new_event_loop()\n            asyncio.set_event_loop(loop)\n            \n            # Limpar √≠ndice\n            success = loop.run_until_complete(self.search_manager.clear_index())\n            \n            # Atualizar interface\n            if success:\n                self.parent.after(0, lambda: messagebox.showinfo(\"Sucesso\", \"√çndice limpo com sucesso!\"))\n                self.parent.after(0, self.refresh_statistics)\n            else:\n                self.parent.after(0, lambda: messagebox.showerror(\"Erro\", \"Erro ao limpar √≠ndice\"))\n                \n        except Exception as e:\n            self.parent.after(0, lambda: messagebox.showerror(\"Erro\", f\"Erro ao limpar √≠ndice: {e}\"))\n        finally:\n            loop.close()\n    \n    def export_search_results(self):\n        \"\"\"Exporta resultados da busca\"\"\"\n        if not self.search_results:\n            messagebox.showwarning(\"Aviso\", \"Nenhum resultado para exportar\")\n            return\n        \n        # Selecionar arquivo de destino\n        file_path = filedialog.asksaveasfilename(\n            defaultextension=\".json\",\n            filetypes=[(\"Arquivo JSON\", \"*.json\"), (\"Todos os arquivos\", \"*.*\")]\n        )\n        \n        if file_path:\n            try:\n                import json\n                \n                # Preparar dados para exporta√ß√£o\n                export_data = {\n                    'search_query': self.search_var.get(),\n                    'search_type': self.search_type_var.get(),\n                    'timestamp': datetime.now().isoformat(),\n                    'total_results': len(self.search_results),\n                    'results': []\n                }\n                \n                # Converter resultados para dicion√°rio\n                for result in self.search_results:\n                    export_data['results'].append({\n                        'document_id': result.document_id,\n                        'file_path': result.file_path,\n                        'title': result.title,\n                        'content_excerpt': result.content_excerpt,\n                        'confidence': result.confidence,\n                        'page_number': result.page_number,\n                        'match_type': result.match_type,\n                        'score': result.score,\n                        'metadata': result.metadata\n                    })\n                \n                # Salvar arquivo\n                with open(file_path, 'w', encoding='utf-8') as f:\n                    json.dump(export_data, f, indent=2, ensure_ascii=False)\n                \n                messagebox.showinfo(\"Sucesso\", f\"Resultados exportados para:\\n{file_path}\")\n                \n            except Exception as e:\n                messagebox.showerror(\"Erro\", f\"Erro ao exportar resultados:\\n{str(e)}\")\n\ndef create_search_window(search_manager=None):\n    \"\"\"Cria janela de busca independente\"\"\"\n    window = tk.Toplevel()\n    window.title(\"üîç Busca Inteligente de Documentos\")\n    window.geometry(\"1000x700\")\n    \n    # Criar interface\n    search_interface = SearchInterface(window, search_manager)\n    \n    return window, search_interface